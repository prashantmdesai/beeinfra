#cloud-config
# Master Node Cloud-Init Configuration
# VM: ${vm_name} (${vm_role})
# Components: ${vm_components}
# Private IP: ${vm_private_ip}

# Set hostname
hostname: ${vm_name}
fqdn: ${vm_name}.local

# Create log directory early
bootcmd:
  - mkdir -p /logs
  - chmod 755 /logs
  - echo "=== Cloud-Init Boot Commands Started at $(date -Iseconds) ===" > /logs/cloud-init-$(date +%Y%m%d-%H%M%S).log

# Configure users
users:
  - name: ${admin_username}
    sudo: ALL=(ALL) NOPASSWD:ALL
    groups: sudo, docker
    shell: /bin/bash
    lock_passwd: false
    ssh_authorized_keys:
      - ${ssh_public_key}

# Set timezone
timezone: America/Chicago

# Package management
package_update: true
package_upgrade: true

# Install required packages
packages:
  - apt-transport-https
  - ca-certificates
  - curl
  - gnupg
  - lsb-release
  - software-properties-common
  - git
  - jq
  - wget
  - unzip
  - net-tools
  - cifs-utils
  - nfs-common

# Write files
write_files:
  # Environment configuration
  - path: /etc/environment.d/platform.conf
    permissions: '0644'
    content: |
      ORGNM=${org_name}
      PLTNM=${platform_name}
      ENVNM=${env_name}
      VM_NAME=${vm_name}
      VM_ROLE=${vm_role}
      VM_COMPONENTS=${vm_components}

  # Azure File Share credentials
  - path: /etc/azure-fileshare.conf
    permissions: '0600'
    content: |
      STORAGE_ACCOUNT_NAME=${storage_account_name}
      FILE_SHARE_NAME=${file_share_name}
      STORAGE_ACCESS_KEY=${storage_access_key}
      MOUNT_POINT=/mnt/${file_share_name}

  # GitHub credentials (owner will be set in runcmd after user creation)
  - path: /home/${admin_username}/.github-credentials
    permissions: '0600'
    content: |
      GITHUB_PAT=${github_pat}
      GITHUB_INFRA_REPO=${github_infra_repo}
      GITHUB_INFRA_PATH=${github_infra_path}

  # Logging helper functions
  - path: /usr/local/bin/log-exec
    permissions: '0755'
    owner: root:root
    content: |
      #!/bin/bash
      # Usage: log-exec <log-file-name> <command> [args...]
      # Creates timestamped log file and logs both command and output
      
      LOG_NAME="$1"
      shift
      TIMESTAMP=$(date +%Y%m%d-%H%M%S)
      LOG_FILE="/logs/$${LOG_NAME}-$${TIMESTAMP}.log"
      
      # Ensure log directory exists
      mkdir -p /logs
      
      # Log the command being executed
      echo "=====================================" >> "$LOG_FILE"
      echo "Command: $@" >> "$LOG_FILE"
      echo "Timestamp: $(date -Iseconds)" >> "$LOG_FILE"
      echo "=====================================" >> "$LOG_FILE"
      echo "" >> "$LOG_FILE"
      
      # Execute command and capture output
      "$@" >> "$LOG_FILE" 2>&1
      EXIT_CODE=$?
      
      # Log completion status
      echo "" >> "$LOG_FILE"
      echo "=====================================" >> "$LOG_FILE"
      echo "Exit Code: $EXIT_CODE" >> "$LOG_FILE"
      echo "Completed: $(date -Iseconds)" >> "$LOG_FILE"
      echo "=====================================" >> "$LOG_FILE"
      
      return $EXIT_CODE

  # Kubernetes configuration
  - path: /etc/kubernetes-config.conf
    permissions: '0644'
    content: |
      K8S_VERSION=${k8s_version}
      K8S_POD_CIDR=${k8s_pod_cidr}
      K8S_CNI=${k8s_cni}

  # Mount Azure File Share script
  - path: /usr/local/bin/mount-azure-fileshare.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -euo pipefail
      
      # Infrastructure Command Logging Standard - Auto-apply tee to all output
      TIMESTAMP=$(date +%Y%m%d-%H%M%S)
      LOG_FILE="/logs/mount-azure-fileshare-$${TIMESTAMP}.log"
      
      # Set script start time for duration calculation
      SCRIPT_START_TIME=$(date +%s)
      
      # Ensure logs directory exists
      mkdir -p /logs
      
      # Redirect all output to both console and log file
      exec > >(tee -a "$LOG_FILE") 2>&1
      
      echo "============================================================================="
      echo "📦 Mount Azure File Share - $(date)"
      echo "============================================================================="
      echo "Script: $0"
      echo "Working Directory: $(pwd)"
      echo "Log File: $LOG_FILE"
      echo "User: $(whoami)"
      echo "============================================================================="
      echo ""
      
      source /etc/azure-fileshare.conf
      
      echo "[$(date)] Starting Azure File Share mount..."
      
      # Create mount point
      mkdir -p "$MOUNT_POINT"
      
      # Create credentials file
      CREDS_FILE="/etc/smbcredentials/$STORAGE_ACCOUNT_NAME.cred"
      mkdir -p /etc/smbcredentials
      echo "username=$STORAGE_ACCOUNT_NAME" > "$CREDS_FILE"
      echo "password=$STORAGE_ACCESS_KEY" >> "$CREDS_FILE"
      chmod 600 "$CREDS_FILE"
      
      # Get beeuser UID and GID for proper ownership
      BEEUSER_UID=$(id -u ${admin_username})
      BEEUSER_GID=$(id -g ${admin_username})
      
      # Test DNS resolution first
      echo "[$(date)] Testing DNS resolution for $STORAGE_ACCOUNT_NAME.file.core.windows.net..."
      for i in {1..5}; do
        if nslookup "$STORAGE_ACCOUNT_NAME.file.core.windows.net"; then
          echo "[$(date)] DNS resolution successful"
          break
        fi
        echo "[$(date)] DNS resolution failed, attempt $i/5, retrying in 10s..."
        sleep 10
      done
      
      # Add to fstab with systemd dependencies (simpler and more reliable than .mount units)
      FSTAB_ENTRY="//$STORAGE_ACCOUNT_NAME.file.core.windows.net/$FILE_SHARE_NAME $MOUNT_POINT cifs nofail,x-systemd.after=network-online.target,x-systemd.requires=network-online.target,credentials=$CREDS_FILE,uid=$BEEUSER_UID,gid=$BEEUSER_GID,dir_mode=0775,file_mode=0664,serverino,nosharesock,actimeo=30,_netdev 0 0"
      if ! grep -q "$MOUNT_POINT" /etc/fstab; then
        echo "$FSTAB_ENTRY" >> /etc/fstab
      fi
      
      # Mount now
      mount -a
      
      # Verify mount
      if ! mountpoint -q "$MOUNT_POINT"; then
        echo "[$(date)] ERROR: Mount verification failed"
        exit 1
      fi
      
      # Create required directories
      mkdir -p "$MOUNT_POINT/k8s-join-token"
      mkdir -p "$MOUNT_POINT/logs"
      mkdir -p "$MOUNT_POINT/configs"
      mkdir -p "$MOUNT_POINT/data"
      
      # Create required directories
      mkdir -p "$MOUNT_POINT/k8s-join-token"
      mkdir -p "$MOUNT_POINT/logs"
      mkdir -p "$MOUNT_POINT/configs"
      mkdir -p "$MOUNT_POINT/data"
      chown -R ${admin_username}:${admin_username} "$MOUNT_POINT"
      
      echo "[$(date)] Azure File Share mounted successfully at $MOUNT_POINT"
      df -h "$MOUNT_POINT"
      
      # Calculate script execution duration
      SCRIPT_END_TIME=$(date +%s)
      SCRIPT_DURATION=$((SCRIPT_END_TIME - SCRIPT_START_TIME))
      
      echo ""
      echo "============================================================================="
      echo "✅ Mount Azure File Share - COMPLETED - $(date)"
      echo "============================================================================="
      echo "Exit Code: 0"
      echo "Duration: $${SCRIPT_DURATION}s"
      echo "============================================================================="



  # Docker installation script
  - path: /usr/local/bin/install-docker.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -euo pipefail
      
      # Infrastructure Command Logging Standard - Auto-apply tee to all output
      TIMESTAMP=$(date +%Y%m%d-%H%M%S)
      LOG_FILE="/logs/install-docker-$${TIMESTAMP}.log"
      
      # Set script start time for duration calculation
      SCRIPT_START_TIME=$(date +%s)
      
      # Ensure logs directory exists
      mkdir -p /logs
      
      # Redirect all output to both console and log file
      exec > >(tee -a "$LOG_FILE") 2>&1
      
      echo "============================================================================="
      echo "🐳 Install Docker - $(date)"
      echo "============================================================================="
      echo "Script: $0"
      echo "Working Directory: $(pwd)"
      echo "Log File: $LOG_FILE"
      echo "User: $(whoami)"
      echo "============================================================================="
      echo ""
      
      # Function to log command and execute
      log_and_run() {
        echo "=====================================" | tee -a "$LOG_FILE"
        echo "Command: $@" | tee -a "$LOG_FILE"
        echo "Timestamp: $(date -Iseconds)" | tee -a "$LOG_FILE"
        echo "=====================================" | tee -a "$LOG_FILE"
        "$@" 2>&1 | tee -a "$LOG_FILE"
        local exit_code=$${PIPESTATUS[0]}
        echo "Exit Code: $exit_code" | tee -a "$LOG_FILE"
        echo "" | tee -a "$LOG_FILE"
        return $exit_code
      }
      
      echo "[$(date)] Installing Docker..." | tee -a "$LOG_FILE"
      
      # Add Docker's official GPG key
      echo "Adding Docker GPG key..." | tee -a "$LOG_FILE"
      log_and_run mkdir -p /etc/apt/keyrings
      log_and_run curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /tmp/docker.gpg
      log_and_run gpg --dearmor -o /etc/apt/keyrings/docker.gpg /tmp/docker.gpg
      log_and_run chmod a+r /etc/apt/keyrings/docker.gpg
      
      # Add Docker repository
      echo "Adding Docker repository..." | tee -a "$LOG_FILE"
      echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list >> "$LOG_FILE"
      
      # Install Docker (non-interactive, use new config files)
      export DEBIAN_FRONTEND=noninteractive
      echo "Updating apt cache..." | tee -a "$LOG_FILE"
      log_and_run apt-get update
      echo "Installing Docker packages..." | tee -a "$LOG_FILE"
      log_and_run apt-get install -y -o Dpkg::Options::="--force-confnew" docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
      
      # Configure Docker daemon
      mkdir -p /etc/docker
      cat > /etc/docker/daemon.json <<EOF
      {
        "exec-opts": ["native.cgroupdriver=systemd"],
        "log-driver": "json-file",
        "log-opts": {
          "max-size": "100m"
        },
        "storage-driver": "overlay2"
      }
      EOF
      
      # Configure containerd for Kubernetes
      echo "[$(date)] Configuring containerd..." | tee -a "$LOG_FILE"
      log_and_run mkdir -p /etc/containerd
      echo "Generating containerd config..." | tee -a "$LOG_FILE"
      containerd config default | tee /etc/containerd/config.toml >> "$LOG_FILE"
      log_and_run sed -i 's/SystemdCgroup = false/SystemdCgroup = true/' /etc/containerd/config.toml
      
      # Enable and start services
      echo "Enabling and starting services..." | tee -a "$LOG_FILE"
      log_and_run systemctl enable containerd
      systemctl restart containerd
      systemctl enable docker
      log_and_run systemctl daemon-reload
      log_and_run systemctl restart docker
      
      # Verify containerd is running
      echo "Waiting for services to start..." | tee -a "$LOG_FILE"
      sleep 5
      log_and_run systemctl status containerd --no-pager
      
      # Add user to docker group
      echo "Adding user to docker group..." | tee -a "$LOG_FILE"
      log_and_run usermod -aG docker ${admin_username}
      
      echo "[$(date)] Docker and containerd installed successfully" | tee -a "$LOG_FILE"
      log_and_run docker --version
      log_and_run containerd --version
      
      # Calculate script execution duration
      SCRIPT_END_TIME=$(date +%s)
      SCRIPT_DURATION=$((SCRIPT_END_TIME - SCRIPT_START_TIME))
      
      echo ""
      echo "============================================================================="
      echo "✅ Install Docker - COMPLETED - $(date)"
      echo "============================================================================="
      echo "Exit Code: 0"
      echo "Duration: $${SCRIPT_DURATION}s"
      echo "============================================================================="

  # Kubernetes installation script
  - path: /usr/local/bin/install-kubernetes.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -euo pipefail
      
      source /etc/kubernetes-config.conf
      
      # Infrastructure Command Logging Standard - Auto-apply tee to all output
      TIMESTAMP=$(date +%Y%m%d-%H%M%S)
      LOG_FILE="/logs/install-kubernetes-$${TIMESTAMP}.log"
      
      # Set script start time for duration calculation
      SCRIPT_START_TIME=$(date +%s)
      
      # Ensure logs directory exists
      mkdir -p /logs
      
      # Redirect all output to both console and log file
      exec > >(tee -a "$LOG_FILE") 2>&1
      
      echo "============================================================================="
      echo "☸️  Install Kubernetes - $(date)"
      echo "============================================================================="
      echo "Script: $0"
      echo "Working Directory: $(pwd)"
      echo "Log File: $LOG_FILE"
      echo "User: $(whoami)"
      echo "Kubernetes Version: $K8S_VERSION"
      echo "============================================================================="
      echo ""
      
      # Function to log command and execute
      log_and_run() {
        echo "=====================================" | tee -a "$LOG_FILE"
        echo "Command: $@" | tee -a "$LOG_FILE"
        echo "Timestamp: $(date -Iseconds)" | tee -a "$LOG_FILE"
        echo "=====================================" | tee -a "$LOG_FILE"
        "$@" 2>&1 | tee -a "$LOG_FILE"
        local exit_code=$${PIPESTATUS[0]}
        echo "Exit Code: $exit_code" | tee -a "$LOG_FILE"
        echo "" | tee -a "$LOG_FILE"
        return $exit_code
      }
      
      echo "[$(date)] Installing Kubernetes $K8S_VERSION..." | tee -a "$LOG_FILE"
      
      # Disable swap
      echo "Disabling swap..." | tee -a "$LOG_FILE"
      log_and_run swapoff -a
      log_and_run sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab
      
      # Load required kernel modules
      echo "Configuring kernel modules..." | tee -a "$LOG_FILE"
      cat > /etc/modules-load.d/k8s.conf <<EOF
      overlay
      br_netfilter
      EOF
      
      log_and_run modprobe overlay
      log_and_run modprobe br_netfilter
      
      # Configure sysctl
      echo "Configuring sysctl..." | tee -a "$LOG_FILE"
      cat > /etc/sysctl.d/k8s.conf <<EOF
      net.bridge.bridge-nf-call-iptables  = 1
      net.bridge.bridge-nf-call-ip6tables = 1
      net.ipv4.ip_forward                 = 1
      EOF
      
      log_and_run sysctl --system
      
      # Add Kubernetes repository
      echo "Adding Kubernetes repository..." | tee -a "$LOG_FILE"
      log_and_run mkdir -p /etc/apt/keyrings
      log_and_run curl -fsSL https://pkgs.k8s.io/core:/stable:/v$K8S_VERSION/deb/Release.key -o /tmp/k8s.key
      log_and_run gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg /tmp/k8s.key
      echo "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v$K8S_VERSION/deb/ /" | tee /etc/apt/sources.list.d/kubernetes.list >> "$LOG_FILE"
      
      # Install Kubernetes components (non-interactive)
      export DEBIAN_FRONTEND=noninteractive
      echo "Updating apt cache..." | tee -a "$LOG_FILE"
      log_and_run apt-get update
      echo "Installing Kubernetes components..." | tee -a "$LOG_FILE"
      log_and_run apt-get install -y -o Dpkg::Options::="--force-confnew" kubelet kubeadm kubectl
      log_and_run apt-mark hold kubelet kubeadm kubectl
      
      # Enable kubelet
      echo "Enabling kubelet..." | tee -a "$LOG_FILE"
      log_and_run systemctl enable kubelet
      
      echo "[$(date)] Kubernetes $K8S_VERSION installed successfully" | tee -a "$LOG_FILE"
      log_and_run kubeadm version
      
      # Calculate script execution duration
      SCRIPT_END_TIME=$(date +%s)
      SCRIPT_DURATION=$((SCRIPT_END_TIME - SCRIPT_START_TIME))
      
      echo ""
      echo "============================================================================="
      echo "✅ Install Kubernetes - COMPLETED - $(date)"
      echo "============================================================================="
      echo "Exit Code: 0"
      echo "Duration: $${SCRIPT_DURATION}s"
      echo "Kubernetes Version: $K8S_VERSION"
      echo "============================================================================="

  # Initialize Kubernetes master script
  - path: /usr/local/bin/init-k8s-master.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -euo pipefail
      
      source /etc/kubernetes-config.conf
      source /etc/azure-fileshare.conf
      
      # Infrastructure Command Logging Standard - Auto-apply tee to all output
      TIMESTAMP=$(date +%Y%m%d-%H%M%S)
      LOG_FILE="/logs/init-k8s-master-$${TIMESTAMP}.log"
      
      # Set script start time for duration calculation
      SCRIPT_START_TIME=$(date +%s)
      
      # Ensure logs directory exists
      mkdir -p /logs
      
      # Redirect all output to both console and log file
      exec > >(tee -a "$LOG_FILE") 2>&1
      
      echo "============================================================================="
      echo "🎯 Initialize Kubernetes Master - $(date)"
      echo "============================================================================="
      echo "Script: $0"
      echo "Working Directory: $(pwd)"
      echo "Log File: $LOG_FILE"
      echo "User: $(whoami)"
      echo "Pod CIDR: $K8S_POD_CIDR"
      echo "============================================================================="
      echo ""
      
      # Function to log command and execute
      log_and_run() {
        echo "=====================================" | tee -a "$LOG_FILE"
        echo "Command: $@" | tee -a "$LOG_FILE"
        echo "Timestamp: $(date -Iseconds)" | tee -a "$LOG_FILE"
        echo "=====================================" | tee -a "$LOG_FILE"
        "$@" 2>&1 | tee -a "$LOG_FILE"
        local exit_code=$${PIPESTATUS[0]}
        echo "Exit Code: $exit_code" | tee -a "$LOG_FILE"
        echo "" | tee -a "$LOG_FILE"
        return $exit_code
      }
      
      echo "[$(date)] Initializing Kubernetes master node..." | tee -a "$LOG_FILE"
      
      # Initialize cluster
      echo "Running kubeadm init..." | tee -a "$LOG_FILE"
      log_and_run kubeadm init --pod-network-cidr=$K8S_POD_CIDR --apiserver-advertise-address=${vm_private_ip} --ignore-preflight-errors=all
      
      # Configure kubectl for root
      echo "Configuring kubectl..." | tee -a "$LOG_FILE"
      export KUBECONFIG=/etc/kubernetes/admin.conf
      
      # Configure kubectl for user
      log_and_run mkdir -p /home/${admin_username}/.kube
      log_and_run cp /etc/kubernetes/admin.conf /home/${admin_username}/.kube/config
      log_and_run chown -R ${admin_username}:${admin_username} /home/${admin_username}/.kube
      
      # Save join command to file share
      echo "Creating join token..." | tee -a "$LOG_FILE"
      JOIN_CMD=$(kubeadm token create --print-join-command 2>&1 | tee -a "$LOG_FILE")
      echo "$JOIN_CMD" | tee "$MOUNT_POINT/k8s-join-token/join-command.sh" >> "$LOG_FILE"
      chmod 644 "$MOUNT_POINT/k8s-join-token/join-command.sh"
      
      # Save cluster info
      echo "Saving cluster info..." | tee -a "$LOG_FILE"
      log_and_run kubectl cluster-info
      kubectl cluster-info > "$MOUNT_POINT/k8s-join-token/cluster-info.txt"
      
      echo "[$(date)] Kubernetes master initialized successfully" | tee -a "$LOG_FILE"
      
      # Calculate script execution duration
      SCRIPT_END_TIME=$(date +%s)
      SCRIPT_DURATION=$((SCRIPT_END_TIME - SCRIPT_START_TIME))
      
      echo ""
      echo "============================================================================="
      echo "✅ Initialize Kubernetes Master - COMPLETED - $(date)"
      echo "============================================================================="
      echo "Exit Code: 0"
      echo "Duration: $${SCRIPT_DURATION}s"
      echo "Pod CIDR: $K8S_POD_CIDR"
      echo "============================================================================="

  # Install Calico CNI script
  - path: /usr/local/bin/install-calico.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -euo pipefail
      
      source /etc/kubernetes-config.conf
      
      # Infrastructure Command Logging Standard - Auto-apply tee to all output
      TIMESTAMP=$(date +%Y%m%d-%H%M%S)
      LOG_FILE="/logs/install-calico-$${TIMESTAMP}.log"
      
      # Set script start time for duration calculation
      SCRIPT_START_TIME=$(date +%s)
      
      # Ensure logs directory exists
      mkdir -p /logs
      
      # Redirect all output to both console and log file
      exec > >(tee -a "$LOG_FILE") 2>&1
      
      echo "============================================================================="
      echo "🌐 Install Calico CNI - $(date)"
      echo "============================================================================="
      echo "Script: $0"
      echo "Working Directory: $(pwd)"
      echo "Log File: $LOG_FILE"
      echo "User: $(whoami)"
      echo "CNI: $K8S_CNI"
      echo "============================================================================="
      echo ""
      
      # Function to log command and execute
      log_and_run() {
        echo "=====================================" | tee -a "$LOG_FILE"
        echo "Command: $@" | tee -a "$LOG_FILE"
        echo "Timestamp: $(date -Iseconds)" | tee -a "$LOG_FILE"
        echo "=====================================" | tee -a "$LOG_FILE"
        "$@" 2>&1 | tee -a "$LOG_FILE"
        local exit_code=$${PIPESTATUS[0]}
        echo "Exit Code: $exit_code" | tee -a "$LOG_FILE"
        echo "" | tee -a "$LOG_FILE"
        return $exit_code
      }
      
      echo "[$(date)] Installing Calico CNI..." | tee -a "$LOG_FILE"
      
      export KUBECONFIG=/etc/kubernetes/admin.conf
      
      # Install Calico operator
      echo "Installing Calico operator..." | tee -a "$LOG_FILE"
      log_and_run kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.27.0/manifests/tigera-operator.yaml
      
      # Wait for operator to be ready
      echo "Waiting for operator..." | tee -a "$LOG_FILE"
      sleep 30
      
      # Install Calico custom resources
      echo "Creating Calico custom resources..." | tee -a "$LOG_FILE"
      cat > /tmp/calico-custom-resources.yaml <<EOF
      apiVersion: operator.tigera.io/v1
      kind: Installation
      metadata:
        name: default
      spec:
        calicoNetwork:
          ipPools:
          - blockSize: 26
            cidr: $K8S_POD_CIDR
            encapsulation: VXLANCrossSubnet
            natOutgoing: Enabled
            nodeSelector: all()
      ---
      apiVersion: operator.tigera.io/v1
      kind: APIServer
      metadata:
        name: default
      spec: {}
      EOF
      
      log_and_run kubectl apply -f /tmp/calico-custom-resources.yaml
      
      echo "[$(date)] Calico CNI installation initiated" | tee -a "$LOG_FILE"
      echo "[$(date)] Waiting for Calico pods to be ready (this may take a few minutes)..." | tee -a "$LOG_FILE"
      
      # Wait for Calico pods
      log_and_run kubectl wait --for=condition=ready pod -l k8s-app=calico-node -n calico-system --timeout=300s || true
      
      echo "[$(date)] Calico CNI installed successfully" | tee -a "$LOG_FILE"
      
      # Install calicoctl binary
      echo "[$(date)] Installing calicoctl binary..." | tee -a "$LOG_FILE"
      CALICO_VERSION="v3.27.0"
      CALICOCTL_URL="https://github.com/projectcalico/calico/releases/download/$${CALICO_VERSION}/calicoctl-linux-amd64"
      
      echo "Downloading calicoctl $${CALICO_VERSION}..." | tee -a "$LOG_FILE"
      log_and_run curl -L -o /tmp/calicoctl "$${CALICOCTL_URL}"
      log_and_run chmod +x /tmp/calicoctl
      log_and_run mv /tmp/calicoctl /usr/local/bin/calicoctl
      
      echo "Verifying calicoctl installation..." | tee -a "$LOG_FILE"
      log_and_run calicoctl version
      
      echo "[$(date)] calicoctl installed successfully" | tee -a "$LOG_FILE"
      
      # Calculate script execution duration
      SCRIPT_END_TIME=$(date +%s)
      SCRIPT_DURATION=$((SCRIPT_END_TIME - SCRIPT_START_TIME))
      
      echo ""
      echo "============================================================================="
      echo "✅ Install Calico CNI - COMPLETED - $(date)"
      echo "============================================================================="
      echo "Exit Code: 0"
      echo "Duration: $${SCRIPT_DURATION}s"
      echo "CNI: $K8S_CNI"
      echo "calicoctl: Installed ($${CALICO_VERSION})"
      echo "============================================================================="

  # Clone infrastructure repository script
  - path: /usr/local/bin/clone-infra-repo.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -euo pipefail
      
      # Infrastructure Command Logging Standard - Auto-apply tee to all output
      TIMESTAMP=$(date +%Y%m%d-%H%M%S)
      LOG_FILE="/logs/clone-infra-repo-$${TIMESTAMP}.log"
      
      # Set script start time for duration calculation
      SCRIPT_START_TIME=$(date +%s)
      
      # Ensure logs directory exists
      mkdir -p /logs
      
      # Redirect all output to both console and log file
      exec > >(tee -a "$LOG_FILE") 2>&1
      
      echo "============================================================================="
      echo "📚 Clone Infrastructure Repository - $(date)"
      echo "============================================================================="
      echo "Script: $0"
      echo "Working Directory: $(pwd)"
      echo "Log File: $LOG_FILE"
      echo "User: $(whoami)"
      echo "============================================================================="
      echo ""
      
      # Function to log command and execute
      log_and_run() {
        echo "=====================================" | tee -a "$LOG_FILE"
        echo "Command: $@" | tee -a "$LOG_FILE"
        echo "Timestamp: $(date -Iseconds)" | tee -a "$LOG_FILE"
        echo "=====================================" | tee -a "$LOG_FILE"
        "$@" 2>&1 | tee -a "$LOG_FILE"
        local exit_code=$${PIPESTATUS[0]}
        echo "Exit Code: $exit_code" | tee -a "$LOG_FILE"
        echo "" | tee -a "$LOG_FILE"
        return $exit_code
      }
      
      source /home/${admin_username}/.github-credentials
      
      echo "[$(date)] Cloning infrastructure repository..." | tee -a "$LOG_FILE"
      
      # Ensure GITHUB_INFRA_PATH directory exists with proper permissions
      echo "Creating target directory: $GITHUB_INFRA_PATH" | tee -a "$LOG_FILE"
      log_and_run mkdir -p "$GITHUB_INFRA_PATH"
      log_and_run chown ${admin_username}:${admin_username} "$GITHUB_INFRA_PATH"
      
      # Remove existing infra subdirectory if present (git will create 'infra' subdirectory)
      echo "Cleaning existing infra directory..." | tee -a "$LOG_FILE"
      log_and_run rm -rf "$GITHUB_INFRA_PATH/infra"
      
      # Clone repository as the user into GITHUB_INFRA_PATH (git creates 'infra' subdirectory from repo name)
      echo "Cloning repository to $GITHUB_INFRA_PATH..." | tee -a "$LOG_FILE"
      su - ${admin_username} -c "cd $GITHUB_INFRA_PATH && git clone https://$GITHUB_PAT@github.com/prashantmdesai/infra.git" 2>&1 | tee -a "$LOG_FILE"
      
      # Set the actual repository path
      ACTUAL_REPO_PATH="$GITHUB_INFRA_PATH/infra"
      
      echo "[$(date)] Infrastructure repository cloned to $ACTUAL_REPO_PATH" | tee -a "$LOG_FILE"
      log_and_run ls -la "$ACTUAL_REPO_PATH"
      
      # Calculate script execution duration
      SCRIPT_END_TIME=$(date +%s)
      SCRIPT_DURATION=$((SCRIPT_END_TIME - SCRIPT_START_TIME))
      
      echo ""
      echo "============================================================================="
      echo "✅ Clone Infrastructure Repository - COMPLETED - $(date)"
      echo "============================================================================="
      echo "Exit Code: 0"
      echo "Duration: $${SCRIPT_DURATION}s"
      echo "Repository Path: $ACTUAL_REPO_PATH"
      echo "============================================================================="

  # Master node bootstrap orchestration script
  - path: /usr/local/bin/bootstrap-master.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -e
      
      TIMESTAMP=$(date +%Y%m%d-%H%M%S)
      LOG_FILE="/logs/bootstrap-master-$${TIMESTAMP}.log"
      SUMMARY_LOG="/logs/bootstrap-summary.log"
      
      # Ensure log directory exists
      mkdir -p /logs
      
      # Function to log and execute with status tracking
      run_step() {
        local step_name="$1"
        local step_script="$2"
        
        echo "" | tee -a "$LOG_FILE" "$SUMMARY_LOG"
        echo "========================================" | tee -a "$LOG_FILE" "$SUMMARY_LOG"
        echo "STEP: $step_name" | tee -a "$LOG_FILE" "$SUMMARY_LOG"
        echo "Started: $(date -Iseconds)" | tee -a "$LOG_FILE" "$SUMMARY_LOG"
        echo "========================================" | tee -a "$LOG_FILE" "$SUMMARY_LOG"
        
        if $step_script 2>&1 | tee -a "$LOG_FILE"; then
          echo "✓ SUCCESS: $step_name completed" | tee -a "$LOG_FILE" "$SUMMARY_LOG"
          echo "Completed: $(date -Iseconds)" | tee -a "$LOG_FILE" "$SUMMARY_LOG"
          return 0
        else
          local exit_code=$?
          echo "✗ FAILED: $step_name (exit code: $exit_code)" | tee -a "$LOG_FILE" "$SUMMARY_LOG"
          echo "Failed: $(date -Iseconds)" | tee -a "$LOG_FILE" "$SUMMARY_LOG"
          return $exit_code
        fi
      }
      
      echo "==========================================" | tee -a "$LOG_FILE" "$SUMMARY_LOG"
      echo "MASTER NODE BOOTSTRAP STARTED" | tee -a "$LOG_FILE" "$SUMMARY_LOG"
      echo "Timestamp: $(date -Iseconds)" | tee -a "$LOG_FILE" "$SUMMARY_LOG"
      echo "Hostname: $(hostname)" | tee -a "$LOG_FILE" "$SUMMARY_LOG"
      echo "==========================================" | tee -a "$LOG_FILE" "$SUMMARY_LOG"
      
      # Step 1: Mount Azure File Share
      run_step "Mount Azure File Share" /usr/local/bin/mount-azure-fileshare.sh
      
      # Step 2: Install Docker
      run_step "Install Docker" /usr/local/bin/install-docker.sh
      
      # Step 3: Install Kubernetes
      run_step "Install Kubernetes" /usr/local/bin/install-kubernetes.sh
      
      # Step 4: Initialize Kubernetes master
      run_step "Initialize Kubernetes Master" /usr/local/bin/init-k8s-master.sh
      
      # Step 5: Install Calico CNI
      run_step "Install Calico CNI" /usr/local/bin/install-calico.sh
      
      # Step 6: Clone infrastructure repository
      run_step "Clone Infrastructure Repository" /usr/local/bin/clone-infra-repo.sh
      
      echo "" | tee -a "$LOG_FILE" "$SUMMARY_LOG"
      echo "==========================================" | tee -a "$LOG_FILE" "$SUMMARY_LOG"
      echo "MASTER NODE BOOTSTRAP COMPLETED" | tee -a "$LOG_FILE" "$SUMMARY_LOG"
      echo "Timestamp: $(date -Iseconds)" | tee -a "$LOG_FILE" "$SUMMARY_LOG"
      echo "Hostname: $(hostname)" | tee -a "$LOG_FILE" "$SUMMARY_LOG"
      echo "==========================================" | tee -a "$LOG_FILE" "$SUMMARY_LOG"
      
      # Copy logs to file share
      source /etc/azure-fileshare.conf
      cp "$LOG_FILE" "$MOUNT_POINT/logs/bootstrap-master-$(hostname)-$(date +%Y%m%d-%H%M%S).log"
      cp "$SUMMARY_LOG" "$MOUNT_POINT/logs/bootstrap-summary-$(hostname)-$(date +%Y%m%d-%H%M%S).log"

# Run commands
runcmd:
  # Fix file ownership (user is created by Azure before runcmd)
  - chown -R ${admin_username}:${admin_username} /home/${admin_username}
  - chown ${admin_username}:${admin_username} /home/${admin_username}/.github-credentials
  
  # Set environment variables globally
  - echo "export ORGNM=${org_name}" >> /etc/profile.d/platform.sh
  - echo "export PLTNM=${platform_name}" >> /etc/profile.d/platform.sh
  - echo "export ENVNM=${env_name}" >> /etc/profile.d/platform.sh
  - echo "export VM_NAME=${vm_name}" >> /etc/profile.d/platform.sh
  - echo "export VM_ROLE=${vm_role}" >> /etc/profile.d/platform.sh
  - echo "export VM_COMPONENTS=${vm_components}" >> /etc/profile.d/platform.sh
  - chmod +x /etc/profile.d/platform.sh
  
  # Run bootstrap script (containerd is now configured in install-docker.sh)
  - /usr/local/bin/bootstrap-master.sh

# Final message
final_message: |
  ========================================
  Cloud-init completed for ${vm_name}
  Role: ${vm_role}
  Components: ${vm_components}
  Bootstrap log: /var/log/bootstrap-master.log
  ========================================
  The system is finally up, after $UPTIME seconds
