#cloud-config
# Worker Node Cloud-Init Configuration
# VM: ${vm_name} (${vm_role})
# Components: ${vm_components}
# Private IP: ${vm_private_ip}

# Set hostname
hostname: ${vm_name}
fqdn: ${vm_name}.local

# Configure users
users:
  - name: ${admin_username}
    sudo: ALL=(ALL) NOPASSWD:ALL
    groups: sudo, docker
    shell: /bin/bash
    lock_passwd: false
    ssh_authorized_keys:
      - ${ssh_public_key}

# Set timezone
timezone: America/Chicago

# Package management
package_update: true
package_upgrade: true

# Install required packages
packages:
  - apt-transport-https
  - ca-certificates
  - curl
  - gnupg
  - lsb-release
  - software-properties-common
  - git
  - jq
  - wget
  - unzip
  - net-tools
  - cifs-utils
  - nfs-common

# Write files
write_files:
  # Environment configuration
  - path: /etc/environment.d/platform.conf
    permissions: '0644'
    content: |
      ORGNM=${org_name}
      PLTNM=${platform_name}
      ENVNM=${env_name}
      VM_NAME=${vm_name}
      VM_ROLE=${vm_role}
      VM_COMPONENTS=${vm_components}

  # Azure File Share credentials
  - path: /etc/azure-fileshare.conf
    permissions: '0600'
    content: |
      STORAGE_ACCOUNT_NAME=${storage_account_name}
      FILE_SHARE_NAME=${file_share_name}
      STORAGE_ACCESS_KEY=${storage_access_key}
      MOUNT_POINT=/mnt/${file_share_name}

  # Kubernetes configuration
  - path: /etc/kubernetes-config.conf
    permissions: '0644'
    content: |
      K8S_VERSION=${k8s_version}
      MASTER_IP=${master_ip}

  # Mount Azure File Share script
  - path: /usr/local/bin/mount-azure-fileshare.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -e
      
      source /etc/azure-fileshare.conf
      
      echo "[$(date)] Starting Azure File Share mount..."
      
      # Create mount point
      mkdir -p "$MOUNT_POINT"
      
      # Create credentials file
      CREDS_FILE="/etc/smbcredentials/$STORAGE_ACCOUNT_NAME.cred"
      mkdir -p /etc/smbcredentials
      echo "username=$STORAGE_ACCOUNT_NAME" > "$CREDS_FILE"
      echo "password=$STORAGE_ACCESS_KEY" >> "$CREDS_FILE"
      chmod 600 "$CREDS_FILE"
      
      # Get beeuser UID and GID for proper ownership
      BEEUSER_UID=$(id -u ${admin_username})
      BEEUSER_GID=$(id -g ${admin_username})
      
      # Create systemd mount unit (replaces fstab for better reliability)
      MOUNT_UNIT_NAME=$(echo "$MOUNT_POINT" | sed 's|^/||;s|/|-|g').mount
      cat > "/etc/systemd/system/$MOUNT_UNIT_NAME" <<EOF
      [Unit]
      Description=Azure File Share Mount for ${file_share_name}
      After=network-online.target
      Wants=network-online.target
      
      [Mount]
      What=//$STORAGE_ACCOUNT_NAME.file.core.windows.net/$FILE_SHARE_NAME
      Where=$MOUNT_POINT
      Type=cifs
      Options=credentials=$CREDS_FILE,uid=$BEEUSER_UID,gid=$BEEUSER_GID,dir_mode=0775,file_mode=0664,serverino,nosharesock,actimeo=30
      TimeoutSec=30
      
      [Install]
      WantedBy=multi-user.target
      EOF
      
      # Enable and start mount
      systemctl daemon-reload
      systemctl enable "$MOUNT_UNIT_NAME"
      systemctl start "$MOUNT_UNIT_NAME"
      
      echo "[$(date)] Azure File Share systemd mount unit created and enabled"
      systemctl status "$MOUNT_UNIT_NAME" --no-pager
      df -h "$MOUNT_POINT"

  # Azure File Share automount unit for on-demand mounting
  - path: /etc/systemd/system/mnt-${file_share_name}.automount
    permissions: '0644'
    content: |
      [Unit]
      Description=Automount Azure File Share ${file_share_name}
      
      [Automount]
      Where=/mnt/${file_share_name}
      TimeoutIdleSec=300
      
      [Install]
      WantedBy=multi-user.target

  # Docker installation script
  - path: /usr/local/bin/install-docker.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -e
      
      echo "[$(date)] Installing Docker..."
      
      # Add Docker's official GPG key
      mkdir -p /etc/apt/keyrings
      curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
      chmod a+r /etc/apt/keyrings/docker.gpg
      
      # Add Docker repository
      echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
      
      # Install Docker
      apt-get update
      apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
      
      # Configure Docker daemon
      mkdir -p /etc/docker
      cat > /etc/docker/daemon.json <<EOF
      {
        "exec-opts": ["native.cgroupdriver=systemd"],
        "log-driver": "json-file",
        "log-opts": {
          "max-size": "100m"
        },
        "storage-driver": "overlay2"
      }
      EOF
      
      # Configure containerd for Kubernetes
      mkdir -p /etc/containerd
      containerd config default | tee /etc/containerd/config.toml
      sed -i 's/SystemdCgroup = false/SystemdCgroup = true/' /etc/containerd/config.toml
      
      # Enable and start services
      systemctl enable containerd
      systemctl restart containerd
      systemctl enable docker
      systemctl daemon-reload
      systemctl restart docker
      
      # Add user to docker group
      usermod -aG docker ${admin_username}
      
      echo "[$(date)] Docker installed successfully"
      docker --version

  # Kubernetes installation script
  - path: /usr/local/bin/install-kubernetes.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -e
      
      source /etc/kubernetes-config.conf
      
      echo "[$(date)] Installing Kubernetes $K8S_VERSION..."
      
      # Disable swap
      swapoff -a
      sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab
      
      # Load required kernel modules
      cat > /etc/modules-load.d/k8s.conf <<EOF
      overlay
      br_netfilter
      EOF
      
      modprobe overlay
      modprobe br_netfilter
      
      # Configure sysctl
      cat > /etc/sysctl.d/k8s.conf <<EOF
      net.bridge.bridge-nf-call-iptables  = 1
      net.bridge.bridge-nf-call-ip6tables = 1
      net.ipv4.ip_forward                 = 1
      EOF
      
      sysctl --system
      
      # Add Kubernetes repository
      mkdir -p /etc/apt/keyrings
      curl -fsSL https://pkgs.k8s.io/core:/stable:/v$K8S_VERSION/deb/Release.key | gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
      echo "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v$K8S_VERSION/deb/ /" | tee /etc/apt/sources.list.d/kubernetes.list
      
      # Install Kubernetes components
      apt-get update
      apt-get install -y kubelet kubeadm kubectl
      apt-mark hold kubelet kubeadm kubectl
      
      # Enable kubelet
      systemctl enable kubelet
      
      echo "[$(date)] Kubernetes $K8S_VERSION installed successfully"

  # Kubernetes cluster join script
  - path: /usr/local/bin/join-k8s-cluster.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -e
      
      # Source Azure File Share configuration
      source /etc/azure-fileshare.conf
      
      echo "[$(date)] Joining Kubernetes cluster..."
      
      # Wait for join command to be available
      JOIN_COMMAND_FILE="$MOUNT_POINT/k8s-join-token/join-command.sh"
      TIMEOUT=300  # 5 minutes timeout
      ELAPSED=0
      
      while [ ! -f "$JOIN_COMMAND_FILE" ] && [ $ELAPSED -lt $TIMEOUT ]; do
        echo "[$(date)] Waiting for join command file... ($ELAPSED/$TIMEOUT seconds)"
        sleep 10
        ELAPSED=$((ELAPSED + 10))
      done
      
      if [ ! -f "$JOIN_COMMAND_FILE" ]; then
        echo "[$(date)] ERROR: Join command file not found after $TIMEOUT seconds"
        exit 1
      fi
      
      # Read and execute join command
      echo "[$(date)] Found join command file, executing..."
      chmod +x "$JOIN_COMMAND_FILE"
      bash "$JOIN_COMMAND_FILE"
      
      echo "[$(date)] Successfully joined Kubernetes cluster"

  # Install calicoctl binary script
  - path: /usr/local/bin/install-calicoctl.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -e
      
      echo "[$(date)] Installing calicoctl..."
      
      CALICO_VERSION="v3.27.0"
      CALICOCTL_URL="https://github.com/projectcalico/calico/releases/download/$${CALICO_VERSION}/calicoctl-linux-amd64"
      
      echo "[$(date)] Downloading calicoctl $${CALICO_VERSION}..."
      curl -L -o /tmp/calicoctl "$${CALICOCTL_URL}"
      chmod +x /tmp/calicoctl
      mv /tmp/calicoctl /usr/local/bin/calicoctl
      
      echo "[$(date)] Verifying calicoctl installation..."
      calicoctl version
      
      echo "[$(date)] calicoctl installed successfully"

  # Worker node bootstrap orchestration script
  - path: /usr/local/bin/bootstrap-worker.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -e
      
      LOG_FILE="/var/log/bootstrap-worker.log"
      
      exec > >(tee -a "$LOG_FILE") 2>&1
      
      echo "=========================================="
      echo "[$(date)] Starting worker node bootstrap"
      echo "=========================================="
      
      # Step 1: Mount Azure File Share
      echo "[$(date)] Step 1: Mounting Azure File Share..."
      /usr/local/bin/mount-azure-fileshare.sh
      
      # Step 2: Install Docker
      echo "[$(date)] Step 2: Installing Docker..."
      /usr/local/bin/install-docker.sh
      
      # Step 3: Install Kubernetes
      echo "[$(date)] Step 3: Installing Kubernetes..."
      /usr/local/bin/install-kubernetes.sh
      
      # Step 4: Join Kubernetes cluster
      echo "[$(date)] Step 4: Joining Kubernetes cluster..."
      /usr/local/bin/join-k8s-cluster.sh
      
      # Step 5: Install calicoctl
      echo "[$(date)] Step 5: Installing calicoctl..."
      /usr/local/bin/install-calicoctl.sh
      
      echo "=========================================="
      echo "[$(date)] Worker node bootstrap completed"
      echo "=========================================="
      
      # Copy log to file share
      source /etc/azure-fileshare.conf
      cp "$LOG_FILE" "$MOUNT_POINT/logs/bootstrap-worker-$(hostname)-$(date +%Y%m%d-%H%M%S).log"

# Run commands
runcmd:
  # Fix file ownership (user is created by Azure before runcmd)
  - chown -R ${admin_username}:${admin_username} /home/${admin_username}
  
  # Set environment variables globally
  - echo "export ORGNM=${org_name}" >> /etc/profile.d/platform.sh
  - echo "export PLTNM=${platform_name}" >> /etc/profile.d/platform.sh
  - echo "export ENVNM=${env_name}" >> /etc/profile.d/platform.sh
  - echo "export VM_NAME=${vm_name}" >> /etc/profile.d/platform.sh
  - echo "export VM_ROLE=${vm_role}" >> /etc/profile.d/platform.sh
  - echo "export VM_COMPONENTS=${vm_components}" >> /etc/profile.d/platform.sh
  - chmod +x /etc/profile.d/platform.sh
  
  # Run bootstrap script
  - /usr/local/bin/bootstrap-worker.sh

# Final message
final_message: |
  ========================================
  Cloud-init completed for ${vm_name}
  Role: ${vm_role}
  Components: ${vm_components}
  Bootstrap log: /var/log/bootstrap-worker.log
  ========================================
  The system is finally up, after $UPTIME seconds
